
%module{ZeroMQ};

// catch the error_t exceptions with a helpful message
%exception{ZMQException}{zmq::error_t}{stdmessage};

%name{ZeroMQ::Context}
class context_t
  %catch{ZMQException}
{
  %name{new} context_t(int io_threads);
  ~context_t();
};


%name{ZeroMQ::Socket}
class socket_t
  %catch{ZMQException}
{
  %name{new} socket_t(context_t& context, int type);
  ~socket_t();

  //void socket_t::getsockopt(int option_name, void *option_value, size_t *option_len)
  //void socket_t::setsockopt(int option_name, const void *option_value, size_t option_len)

  void bind(char* endpoint);
  void connect(const char *endpoint);

};


%name{ZeroMQ::Message}
class message_t
  %catch{ZMQException}
{
  %name{new} message_t(char* data, size_t %length{data})
    %code{%
      /* Note: we need to copy data and provide a cleanup function */
      RETVAL = new zmq::message_t(data, length(data), NULL); 
    %};
  //%name{new} message_t();
  //%name{new} message_t(size_t size_);
  //%name{new} message_t(MsgData* data, size_t size_, free_fn *ffn_, void *hint_ = NULL);
  ~message_t();

  size_t size();
  
  //MsgData* data();
  char* data()
    %code{% RETVAL = (char*)THIS->data(); %};
};


